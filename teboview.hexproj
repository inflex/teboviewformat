{"dataProcessor":"{\"links\":{},\"nodes\":{}}","filePath":"/home/pld/development/pld/teboviewformat/samples/cds2f_NSA911R0-0329.tvw","patches":[],"pattern":"struct pstr {\n\tu8 str_size;\n\tchar value[str_size];\n};\n\nstruct layer_start_s {\n\tu32 magic[4];\n};\n\nstruct abort_s {\n\tstd::print(\"filesize {}\", std::mem::size());\n\tpadding[std::mem::size() -$ -1];\n};\n\nstruct dcode_s {\n\tu32 a; \n\tu32 x;\n\tu32 y;\n\tu32 shape_type;\n\tu32 e1;\n\tu32 e2;\n}[[static]];\n\nstruct layer_header_s {\n\tpstr layer_name;\n\tpstr layer_name_2;\n\tpstr layer_filename;\n\tu32\tlayer_type;\n\tu32 line_color;\n\tu32 pad_color;\n}[[static]];\n\nstruct pad_s {\n\tu32 net;\n\tu32 dcode;\n\ts32 x;\n\ts32 y;\n\tpstr strings[3];\n};\n\nstruct line_s {\n\tu32 net;\n\tu32 dcode;\n\ts32 x0;\n\ts32 y0;\n\ts32 x1;\n\ts32 y1;\n}[[static]];\n\nstruct arc_s {\n\tu32 net;\n\tu32 dcode;\n\ts32 x;\n\ts32 y;\n\ts32 a;\n\ts32 b;\n\ts32 c;\n}[[static]];\n\nstruct edge_s {\n\ts32 x;\n\ts32 y;\n}[[static]];\n\nstruct void_s {\n\tu32 type;\n\tu32 edge_count;\n\tif (edge_count > 1000) abort_s x;\n\telse\n\tedge_s edges[edge_count];\n};\n\nstruct surface_s {\n\tu32 type;\n\tu32 net;\n\tu32 edge_count;\n\tif (edge_count < 1000)\tedge_s edges[edge_count];\n\telse abort_s x;\n\t\n\tu32 void_count;\n\tif (void_count > 1000) abort_s x;\n\telse\n\tvoid_s voids[void_count];\n};\n\nstruct ukn1_s {\n\tu32 data[6];\n};\n\nstruct text_s {\n\tpstr partname;\n\ts32 x;\n\ts32 y;\n\tu32 ukn1;\n\tu32 ukn2;\n\tu32 rotation;\n\tu8 data[19];\n};\n\nstruct layer_doc_s {\n\tu32 item_count;\n\t\n\tdcode_s dcodes[while(std::mem::read_unsigned($ +4, 4) != 0)];\n\tu32 dcode_end_one;\n\tu32 dcode_end_zero;\n\t\n\tu32\tpad_start;\n\tu32 pad_count;\n\tif (pad_count > 0) u32 pads_type;\n\tif (pad_count > 1000) abort_s x;\n\telse\tpad_s pads[pad_count];\n\n\tu32 lines_count;\n\tif (lines_count>0) u32 lines_type;\n\tline_s lines[lines_count];\n\t\n\ts32 arcs_count;\n\tif (arcs_count > 0) u32 arcs_type;\n\tarc_s arcs[arcs_count];\n\n\tu32 surfaces_count;\n\tsurface_s surfaces[surfaces_count];\n\t\n\tu32 next_1;\n\tif (next_1 == 0xFFFFFFFF) {\n\t\tu32 unk1_count;\n\t\tukn1_s ukn1s[unk1_count];\n\t\tu32 dummy;\n\t}\n\t\n\tu32 texts_count;\n\tif (texts_count > 0) u32 texts_unknown1;\n\ttext_s\ttexts[texts_count];\n\t\n//\tu8 ending[48];\n};\nenum UTESTABLE_REASON : u8 {\n\tACCESSIBLE = 0,\n\tNEEDLESS = 1,\n\tMASK = 2,\n\tOVERLAPPED = 3,\n\tNO_APPROPRIATE_PROBE = 4,\n\tSMD = 5,\n\tNO_SELECT_CONDITION = 6,\n\tNAIL_ACCESS = 7,\n\tMASK_AND_OVERLAPPED = 8,\n\tUNTESTABLE_REASON,\n\tTHERE_ARE_TWO_MORE_PINS_ON_TP,\n\tFAILED_TO_LOAD_PROBE_DB,\n\tPRESSBAR,\n\tTRANSITION_PROBE,\n\tSTANDARD,\n\tON_THE_OTHER_SIZE\n};\n\nenum LT : u32 {\n\tTVW_LT_DOCUMENT = 0,\n\tTVW_LT_TOP,\n\tTVW_LT_BOTTOM,\n\tTVW_LT_SIGNAL,\n\tTVW_LT_POWER_GROUND,\n\tTVW_LT_SOLDER_MASK_TOP,\n\tTVW_LT_SOLDER_MASK_BOTTOM,\n\tTVW_LT_SILKSCREEN_TOP,\n\tTVW_LT_SILKSCREEN_BOTTOM,\n\tTVW_LT_PASTE_TOP,\n\tTVW_LT_PASTE_BOTTOM,\n\tTVW_LT_DRILL,\n\tTVW_LT_ROUL,\n\tTVW_LT_LAYER_TYPE_MAX\n};\n\nstruct top_element_10_s { // 16 dec / oblong annuared hole (usb plug mount))\n\ts32 x;\n\ts32 y;\n\tu8\ttest_1; // hole present?\n\tu8  test_2; // see enum for reason codes\n\tu8 test_3;\n\tu8 test_4;\n\tif (test_1 == 0) {\n\t\ts32 offset_x;\n\t\ts32 offset_y;\n\t\ts32 width;\n\t\ts32 height;\n\t\tu8 t1_unknown;\n\t}\n\tif (test_4 == 1) {\n\t\ts32 x0;\n\t\ts32 y0;\n\t\ts32 x1;\n\t\ts32 y1;\n\t} \n\tif (test_3 == 1) {\n\t\ts32 x0;\n\t\ts32 y0;\n\t\ts32 x1;\n\t\ts32 y1;\n\t\ts32 eat[3];\n\t}\n\tu8 untestable_reason;\n\tif (test_1 == 1) u8 unknown;\n};\n\n\n\nstruct top_item_s {\n\tu32 net;\n\tu32 part;\n\ts32 x;\n\ts32 y;\n\tu8 b[4];\n\tu32 u[4];\n\tu8 t1;\n\tif (t1 == 1) {\n\t\tu8 buf[17];\n\t} else {\n\t\tu8 t2;\n\t}\n};\n\t\nstruct rectangle_s {\n\ts32 x0;\n\ts32 y0;\n\ts32 x1;\n\ts32 y1;\n}[[static]];\n\nstruct rectangles_s {\n\tu32 count;\n\trectangle_s list[count];\n};\n\nstruct point_s {\n\ts32 x;\n\ts32 y;\n}[[static]];\n\nstruct poly_s {\n\tu32 point_count;\n\tstd::print(\"Poly_s polygon count {} 0x{:x}\", point_count, $);\n\tpoint_s points[point_count];\n\tstd::print(\"Terminator at 0x{:x}\", $);\n//\tu32 terminator;\n\t\n};\n\nstruct top_element_s {\n\tu32 net;\n\tu32 itype;\n\ttop_element_10_s element;\n\n};\n\nstruct trace_segment_s {\n\n\tu32 net;\n\tu32 dcode;\n\tpoint_s a;\n\tpoint_s b;\n};\n\nstruct top_single_void {\n\tu32 net;\n\tu32 edge_count;\n\tpoint_s outline[edge_count];//[[static]];\n};\n\nstruct top_surface_void_s {\n\tu32 count;\n\ttop_single_void voids[3];\n//\tu32 nextnet;\n\t//u32 next_edge_count;\n};\n\nstruct top_surface_s {\n\n\tu32 count;\n\tpoint_s points[count];\n\tu32 void;\n\ttop_surface_void_s voids;\n\t\n};\n\n\nstruct layer_bottom_s {\n\tline_s\tlines[while(std::mem::read_unsigned($ +20, 4) == 0)];\n\tline_s\tend_line;\n\n\tu32 segment_count;\n\tu32 seg_unknown;\n\ttrace_segment_s segments[segment_count];\n\t\n\t// Outlines\n\tu32 unknown_zero;\n\tu32 unknown_one;\n\tu32 outline_count; //?\n\tu32 net; // known\n//\tu32 edge_count; // known\n\t// absorb\n//\tu32 absorb[2]; // does contain data, but for now just absorb\n//\ttop_surface_s surface[1];\n};\n\nstruct tb_void_s {\n\t\n};\nstruct outline_and_voids_s {\n\tu32 segment_count;\n\tu32 void_count;\n\ttrace_segment_s segments[segment_count];\n\tvoid_s voids[void_count];\n};\n\nstruct top_void_s {\n\tu32 unknown;\n\tu32 count;\n\tpoint_s points[count];\n};\n\nstruct layer_top_s {\n\n\t// trace styles\n\t//\n\tline_s\tlines[while(std::mem::read_unsigned($ +20, 4) == 0)];\n\tline_s\tend_line;\n\t\n\t// Pads/holes\n\ttop_element_s elements[while(std::mem::read_unsigned($, 4) < lines[0].net)];\n\t\n\t// Trace segments\n\tu32 segment_count;\n\tu32 unknow_segment_1;\n\ttrace_segment_s segments[segment_count];\n\t\n\t// Outlines\n\tu32 unknown_zero;\n\tu32 unknown_one;\n\tu32 unknown_two;\n\tu32 net;\n\tu32 outline_count; //?\n\tpoint_s outline[outline_count];\n\t\n\t// now the voids\n\tu32 void_zero;\n\tu32 void_count;\n\ttop_void_s voids[void_count];\n//\tu32 net; // known\n\t\n\t\n\t\n//\tu32 edge_count; // known\n\t// absorb\n//\tu32 absorb[2]; // does contain data, but for now just absorb\n//\ttop_surface_s surface[1];\n\t\n//\tu32 points_count;\n\t//point_s poly_1[points_count];\n\t\n};\n\nstruct drill_tool_s {\n\tpstr name;\n\tu8 type;\n\tu32 size;\n\tu8 unknown[0x17];\n};\n\nstruct drill_s {\n\tu8 unknown;\n\tu32 net;\n\tu32 tool;\n\ts32 x;\n\ts32 y;\n};\n\t\nstruct layer_drill_s {\n\tu32 dcode_count;\n\tu32 tool_count;\n\tdrill_tool_s tools[tool_count -1];\n\t\n\tu32 drill_count;\n\tu8 unknown[0x14];\n\tdrill_s drills[drill_count];\n\t\n\t\n};\n\nstruct layer_outline_s {\n\t\n};\n\nstruct layer_s {\n\tlayer_header_s header;\n\tif (header.layer_type == LT::TVW_LT_SILKSCREEN_TOP || header.layer_type == LT::TVW_LT_SILKSCREEN_BOTTOM) {\n\t\tlayer_doc_s layer;\n\t} \n\telse if (header.layer_type == LT::TVW_LT_SOLDER_MASK_TOP || header.layer_type == LT::TVW_LT_SOLDER_MASK_BOTTOM) {\n\t\tlayer_doc_s layer;\n\t}\n\telse if (header.layer_type == LT::TVW_LT_TOP) {\n\t\tlayer_top_s layer;\n\t}\n\telse if (header.layer_type == LT::TVW_LT_BOTTOM) {\n\t\tlayer_bottom_s layer;\n\t}\n\telse if (header.layer_type == LT::TVW_LT_DRILL) {\n\t\tlayer_drill_s layer;\n\t}\n\telse if (header.layer_type == LT::TVW_LT_ROUL) {\n\t\tlayer_outline_s layer;\n\t}\n\telse {\n\t\tlayer_doc_s layer;\n\t}\n};\n\nstruct header_s {\n\tpstr magic;\n\tu32  ukv;\n\tpstr customer_id;\n\tpstr password;\n\tpstr date;\n\tpstr h5;\n\tpstr h6;\n\tpstr h7;\n\tu32\t\tu3;\n\tu32\t\tu4;\n\tu32\t\tu5;\n\tu32\t\tlayer_count;\n\tu32 \tzero;\n};\n\nfn find_end( u32 limit ) {\n\tfor (u32 i = 0, i < limit, i = i +1){\n\t\tif ((std::mem::read_unsigned($ +i,3) == 0) && (std::mem::read_unsigned($ +i+3,4) == 2) && (std::mem::read_unsigned($ +i+7,4) ==1)) return i;\n\t}\n\treturn limit;\n};\n\nstruct layer_ablock_s {\n\tu8 prebuffer[find_end(1000) +11];\n\tlayer_s layer;\n};\n\nfn layer_jump_bot(){\n\treturn std::mem::find_sequence(0, 6, 'B', 'O', 'T', 'T');\n};\n\nfn layer_jump_top(){\n\treturn std::mem::find_sequence(0, 3, 'T', 'O', 'P', 3);\n};\n\n#pragma pattern_limit 0x4000;\nheader_s main @ 0;\nlayer_s top @ addressof(main) +layer_jump_top();\n//layer_s layer_bottom @ addressof(main) + layer_jump_bot();\n//layer_ablock_s layers[8] @ $;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}